\title{Concourse}{index}

\use-plugin{concourse-docs}
\styled{index}

\splash-intro{
  \inline-header{Concourse is an open-source continuous thing-doer.}

  Built on the simple mechanics of \reference{resources}{resources},
  \reference{tasks}{tasks}, and \reference{jobs}{jobs}, Concourse presents a
  general approach to automation that makes it great for
  \link{CI}{https://en.wikipedia.org/wiki/Continuous_integration}/\link{CD}{https://en.wikipedia.org/wiki/Continuous_delivery}.

  \button{\reference{quick-start}}
}{
  \download-links
}

\side-by-side{
  \inline-header{Configure as code}

  \codeblock{yaml}{{{
  resources:
  - name: booklit
    type: git
    source: {uri: "https://github.com/vito/booklit"}

  jobs:
  - name: unit
    plan:
    - get: booklit
      trigger: true
    - task: test
      file: booklit/ci/test.yml
  }}}
}{
  \inline-header{Visualize to verify}

  \include-template{basic-pipeline-svg}
}

\side-by-side{
  A Concourse \reference{pipelines}{pipeline} is like a distributed, continuous
  \code{Makefile}.

  Each \reference{jobs}{job} has a \reference{schema.job.plan}{build plan}
  declaring the job's input \reference{resources}{resources} and what to run
  with them when they change.
}{
  Your pipeline is then visualized in the web UI, taking only one click to get
  from a failed job to seeing why it failed.

  The visualization provides a "gut check" feedback loop: if it \italic{looks}
  wrong, it probably \italic{is} wrong.
}

\inline-header{A more complicated example...}

Jobs can depend on other jobs by configuring
\reference{schema.step.get-step.passed}{\code{passed}} constraints. The
resulting chain of jobs and resources is a dependency graph that continuously
pushes your project forward, from source code to production.

\include-template{pipeline-image}

\italic{This particular pipeline can be found in the \link{Booklit
repository}{https://github.com/vito/booklit/blob/8741a4ca3116dcf24c30fedfa78e4aadcaff178a/ci/pipeline.yml}.}

\splash-example{CI under source control}{
  All administration is done using \reference{fly-cli}{the \code{fly} CLI}. The
  \reference{fly-set-pipeline} command pushes the config up to Concourse. Once it
  looks good, you can then check the file in to source control. This makes it
  easy to recover if your Concourse server burns down.
}{
  \codeblock{sh}{{{
  $ fly -t ci set-pipeline -p booklit -c pipeline.yml
  $ vim pipeline.yml
  $ fly -t ci set-pipeline -p booklit -c pipeline.yml
  $ git add pipeline.yml
  $ git commit -m "initial pipeline"
  }}}
}

\splash-example{Reproducible, debuggable builds}{
  Everything runs in containers, ensuring a clean environment on every run.

  Each \reference{tasks}{task} specifies its own image, giving it full control
  over its dependencies, rather than managing them on your workers.

  The \reference{fly-intercept} command will pop you right into one of your
  build's containers, which can be useful for debugging.
}{
  \codeblock{sh}{{{
  $ fly -t ci intercept -j booklit/unit -s unit
  root@2c15ff11:/tmp/build/0df9eea0# ps
      PID TTY          TIME CMD
      171 pts/1    00:00:00 bash
     1876 pts/1    00:00:00 ps
  root@2c15ff11:/tmp/build/0df9eea0# ls
  depspath  gopath
  root@2c15ff11:/tmp/build/0df9eea0# █
  }}}
}

\splash-example{Rapid local iteration}{
  The \reference{fly-execute} command executes a task as a one-off build using
  your local changes. This build runs in exactly the same way it would run in
  your pipeline, without you having to repeatedly push broken commits until it
  works.

  When a job fails, you can also use \reference{fly-execute} with \code{-j}
  flag to run with the same inputs as the failed job. You can then replace an
  input with your local changes with \code{-i} to test if your fix is valid.
}{
  \codeblock{sh}{{{
  ~/booklit $ fly -t ci execute -c ci/test.yml
  executing build 1 at http://localhost:8080/builds/1
  initializing
  booklit: 4.74 MiB/s 0s
  running gopath/src/github.com/vito/booklit/ci/test
  fetching dependencies...
  installing ginkgo...
  running tests...
  █
  }}}
}

\inline-header{Bring your own integrations}

\side-by-side{
  \codeblock{yaml}{{{
  resource_types:
  - name: rubygem
    type: registry-image
    source:
      repository: troykinsella/concourse-rubygems-resource

  resources:
  - name: rspec-gem
    type: rubygem
    source: {gem: rspec}

  jobs:
  - name: bundle
    plan:
    - get: rspec-gem
      trigger: true
    - # ...
  }}}
}{
  Concourse does not have a complex plugin system. Instead, it has a single
  strong abstraction.

  The \code{resources} section of a pipeline lists
  \reference{resources}{resources}, which are abstract external locations where
  your pipeline will monitor for changes, fetch bits from, and push bits to.

  For example, a resource with type \code{git} refers to a git repository,
  which will be \code{clone}d in a \reference{get-step} and \code{push}ed to in
  a \reference{put-step}. Behind the scenes, Concourse will continuously run
  \code{git fetch} to look for new commits that jobs may want to trigger on.

  At its core, though, Concourse knows nothing about Git. It comes with a
  \code{git} resource type out of the box, but you could just as easily bring
  your own into your pipeline. Resource types are implemented as container
  images, fetched using the \code{registry-image} resource type.
}

\split-sections

\include-section{./docs.lit}
\include-section{./examples.lit}
\include-section{./project.lit}
